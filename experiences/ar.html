<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<script src='https://rawcdn.githack.com/jeromeetienne/AR.js/354a5d89114fe3029b4ef2bab665b45015d98d40/three.js/examples/vendor/three.js/build/three.min.js'></script>
<script src='https://cdn.rawgit.com/jeromeetienne/AR.js/1.6.2/three.js/build/ar.min.js'></script>

<style>
	body {
		overflow: hidden;
	}

	scene-pointer {
		display: block;
		position: absolute;

		top: calc(50% - .5vmax);
		left: calc(50% - .5vmax);

		width: 1vmax;
		height: 1vmax;

		background-color: violet;
		border-radius: 100vw;
		z-index: 20;
		mix-blend-mode: difference;
	}

	scene-action {
		display: block;
		position: absolute;

		left: calc(50% - 2.5vmax);
		bottom: calc(10% - 2.5vmax);

		width: 10vmax;
		height: 10vmax;
		max-width: 100px;
		max-height: 100px;

		background-color: white;
		border-radius: 100vw;
		z-index: 20;
		mix-blend-mode: difference;
		cursor: pointer;
	}

	scene-action:active {
		opacity: .5;
	}
</style>

<script>
	const gridSize = 2;
	const halfGridSize = gridSize / 2;
	const gridCells = 10;
	const cellSize = gridSize / gridCells;

	const objects = [];
	const onRenderFcts = [];

	const renderer = new THREE.WebGLRenderer({
		antialias: true,
		alpha: true
	});

	let innerWidth = window.innerWidth;
	let innerHeight = window.innerHeight;

	renderer.setClearColor(new THREE.Color('lightgrey'), 0);
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.domElement.style.position = 'absolute'
	renderer.domElement.style.top = '0px'
	renderer.domElement.style.left = '0px'
	document.body.appendChild(renderer.domElement);

	const scene = new THREE.Scene();
	const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
	scene.add(camera);

	const arToolkitSource = new THREEx.ArToolkitSource({ sourceType: 'webcam' });
	
	const ambientLight = new THREE.AmbientLight(0x222222);
	scene.add(ambientLight);

	const directionalLight = new THREE.DirectionalLight( 0x999999 );
	directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
	scene.add( directionalLight );

	arToolkitSource.init(() => {
		const pointer = document.createElement('scene-pointer');
		const action = document.createElement('scene-action');

		document.body.appendChild(pointer);
		document.body.appendChild(action);

		action.addEventListener('click', onActionClick);
		onResize();
	});
	window.addEventListener('resize', onResize);

	function onResize() {
		innerWidth = window.innerWidth;
		innerHeight = window.innerHeight;

		arToolkitSource.onResize();
		arToolkitSource.copySizeTo(renderer.domElement);
		if (arToolkitContext && arToolkitContext.arController !== null) {
			arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)
		}
	}

	// create atToolkitContext
	const arToolkitContext = new THREEx.ArToolkitContext({
		cameraParametersUrl: 'https://cdn.rawgit.com/jeromeetienne/AR.js/b0fec0c2/data/data/camera_para.dat',
		detectionMode: 'mono',
	});
	// initialize it
	arToolkitContext.init(function onCompleted() {
		// copy projection matrix to camera
		camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
	})

	// update artoolkit on every frame
	onRenderFcts.push(function () {
		if (arToolkitSource.ready === false) return

		arToolkitContext.update(arToolkitSource.domElement)

		// update scene.visible if the marker is seen
		scene.visible = camera.visible
	})

	// init controls for camera
	const markerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
		type: 'pattern',
		patternUrl: 'https://raw.githubusercontent.com/jeromeetienne/AR.js/master/data/data/patt.hiro',
		// patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.kanji',
		// as we controls the camera, set changeMatrixMode: 'cameraTransformMatrix'
		changeMatrixMode: 'cameraTransformMatrix'
	})

	// as we do changeMatrixMode: 'cameraTransformMatrix', start with invisible scene
	scene.visible = false

	const rollOverGeo = new THREE.BoxBufferGeometry(cellSize, cellSize, cellSize);
	const rollOverMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.5, transparent: true });
	const rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
	scene.add(rollOverMesh);

	const cubeGeo = new THREE.BoxBufferGeometry(cellSize, cellSize, cellSize);
	const cubeMaterial = new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff });


	const planeGeometry = new THREE.PlaneBufferGeometry(1000, 1000);
	const plane = new THREE.Mesh(planeGeometry, new THREE.MeshBasicMaterial({ visible: false }));
	planeGeometry.rotateX(- Math.PI / 2);
	scene.add(plane);
	objects.push(plane);

	const raycaster = new THREE.Raycaster();
	const mouse = new THREE.Vector2();

	const gridHelper = new THREE.GridHelper(2, 10);
	scene.add(gridHelper);

	let INTERSECTED;

	onRenderFcts.push(() => {
		mouse.set(0, 0);
		camera.updateMatrixWorld();
		raycaster.setFromCamera(mouse, camera);
		const intersects = raycaster.intersectObjects(objects);

		if (intersects && intersects.length > 0) {
			const intersect = intersects[0];

			INTERSECTED = intersects[0].object;
			
			INTERSECTED.material.color.setHex(0xff0000);

			rollOverMesh.position.copy(intersect.point).add(intersect.face.normal.multiplyScalar(.1));
			rollOverMesh.position.divideScalar(cellSize).floor().multiplyScalar(cellSize).addScalar(cellSize / 2);
		}
	});

	// addEditor();

	//////////////////////////////////////////////////////////////////////////////////
	// render the whole thing on the page
	//////////////////////////////////////////////////////////////////////////////////

	// render the scene
	onRenderFcts.push(function () {
		renderer.render(scene, camera);
	})

	// run the rendering loop
	let lastTimeMsec = null
	requestAnimationFrame(function animate(nowMsec) {
		// keep looping
		requestAnimationFrame(animate);
		// measure time2
		lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60
		const deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec = nowMsec
		// call each update function
		onRenderFcts.forEach(function (onRenderFct) {
			onRenderFct(deltaMsec / 1000, nowMsec / 1000)
		})
	});

	function onActionClick(e) {
		e.preventDefault();

		mouse.set(0, 0);
		camera.updateMatrixWorld();
		raycaster.setFromCamera(mouse, camera);
		const intersects = raycaster.intersectObjects(objects);

		if (intersects && intersects.length > 0) {
			const intersect = intersects[0];
			addVoxel(intersect);
		}
	}

	function addEditor() {
		const geometry = new THREE.BoxBufferGeometry(cellSize, cellSize, cellSize);
		const spread = 1;
		const boundary = gridCells * spread;
		const halfSize = boundary / 2 * cellSize;

		for (let i = 0; i < boundary; i++) {
			for (let j = 0; j < boundary; j++) {
				var object = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: .5, transparent: true }));

				object.position.x = i * cellSize - halfSize;
				object.position.y = cellSize / 2;
				object.position.z = j * cellSize - halfSize;
				object.scale.x = .95;
				object.scale.z = .95;

				objects.push(object);
				scene.add(object);
			}
		}
	}

	function addVoxel(intersect) {
		const voxel = new THREE.Mesh(cubeGeo, cubeMaterial);
		voxel.position.copy(intersect.point).add(intersect.face.normal.multiplyScalar(.1));
		voxel.position.divideScalar(cellSize).floor().multiplyScalar(cellSize).addScalar(cellSize / 2);

		voxel.material.color.setHex(Math.random() * 0xffffff);
		scene.add(voxel);
		objects.push(voxel);
	}

</script>